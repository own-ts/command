import type { ICommand } from "./flags"
import { Command } from "./command"

export interface CompletionFlag {
    name: string
    shorthand: string
    values?: string[]
    isBool: boolean
}
export interface CompletionCommand {
    name: string
    children?: CompletionCommand[]
    flags?: CompletionFlag[]
}

/**
 * Generate the autocompletion script for bash.
 * Generated by Gemini.
 */
export function bashCompletion(cmd: CompletionCommand): string {
    const binName = cmd.name
    const functionName = `__${binName.replace(/[^a-zA-Z0-9]/g, '_')}_completion`

    // Flatten all subcommands and flags into a mapping for the script
    const commandsData = flattenCommands(cmd)

    return `
# Bash completion for ${binName}
${functionName}() {
    local cur prev opts
    COMPREPLY=()
    cur="\${COMP_WORDS[COMP_CWORD]}"
    prev="\${COMP_WORDS[COMP_CWORD-1]}"

    # Map command paths to their respective flags and subcommands
    declare -A cmd_flags
    declare -A cmd_subs

    ${Object.entries(commandsData).map(([path, data]) => {
        const flags = data.flags.map(f => `--${f.name} -${f.shorthand}`).join(' ')
        const subs = data.subs.join(' ')
        return `cmd_flags["${path}"]="${flags}"\n    cmd_subs["${path}"]="${subs}"`
    }).join('\n    ')}

    # Find the current command path by iterating through words
    local i=0
    local cmd_path="${binName}"
    for (( i=1; i < COMP_CWORD; i++ )); do
        local word="\${COMP_WORDS[i]}"
        # Skip flags to find the next subcommand
        if [[ "\${word}" != -* ]]; then
            if [[ -n "\${cmd_subs["$cmd_path $word"]}" ]]; then
                cmd_path="$cmd_path $word"
            fi
        fi
    done

    # Handle flag value completion
    case "$prev" in
        ${Object.entries(commandsData).flatMap(([_, data]) => 
            data.flags.filter(f => !f.isBool).map(f => {
                const condition = `--${f.name}|-${f.shorthand})`
                if (f.values && f.values.length > 0) {
                    // Use predefined values
                    return `${condition}\n            COMPREPLY=( $(compgen -W "${f.values.join(' ')}" -- "$cur") )\n            return 0\n            ;;`
                } else {
                    // Default to local file path completion
                    return `${condition}\n            COMPREPLY=( $(compgen -f -- "$cur") )\n            return 0\n            ;;`
                }
            })
        ).join('\n        ')}
    esac

    # If currently typing a flag (starts with -)
    if [[ "$cur" == -* ]]; then
        COMPREPLY=( $(compgen -W "\${cmd_flags["$cmd_path"]}" -- "$cur") )
        return 0
    fi

    # Default to subcommands completion
    COMPREPLY=( $(compgen -W "\${cmd_subs["$cmd_path"]}" -- "$cur") )
}

# -o default allows bash to fallback to default filename completion if COMPREPLY is empty
complete -o default -F ${functionName} ${binName}
`
}

/**
 * Helper: Flatten nested command structures for easier script processing.
 * Generated by Gemini.
 */
function flattenCommands(cmd: CompletionCommand, path: string = ''): Record<string, { subs: string[], flags: CompletionFlag[] }> {
    const currentPath = path ? `${path} ${cmd.name}` : cmd.name
    const result: Record<string, { subs: string[], flags: CompletionFlag[] }> = {}

    const subs = cmd.children?.map(c => c.name) || []
    const flags = cmd.flags || []

    result[currentPath] = { subs, flags }

    if (cmd.children) {
        for (const child of cmd.children) {
            Object.assign(result, flattenCommands(child, currentPath))
        }
    }

    return result
}

function fromCommand(cmd: ICommand): CompletionCommand {
    let flags: CompletionFlag[] | undefined
    for (const flag of cmd.flags) {
        if (!flags) {
            flags = []
        }
        flags.push({
            name: flag.name,
            shorthand: flag.short,
            values: flag.values?.map((v) => `${v}`),
            isBool: flag.isBool(),
        })
    }
    return {
        name: cmd.name,
        flags: flags,
    }
}
function addChild(parent: CompletionCommand, cmd: ICommand) {
    const c = fromCommand(cmd)
    if (!parent.children) {
        parent.children = []
    }
    parent.children.push(c)

    for (const v of cmd.values()) {
        addChild(c, v)
    }
}

export interface CreateCompletionOptions {
    name?: string
    usage?: string
    usageLong?: string
}
export function createCompletion(opts?: CreateCompletionOptions) {
    const cmd = new Command({
        name: opts?.name ?? 'completion',
        usage: opts?.usage ?? 'Generate the autocompletion script for the specified shell',
        usageLong: opts?.usageLong ?? `Generate the autocompletion script for webpc for the specified shell.
See each sub-command's help for details on how to use the generated script.`,
    }).add(
        createBashCompletion(),
    )
    return cmd
}
function bashUsage(cmd: ICommand) {
    const use = cmd.use()
    let parent = cmd
    while (parent.parent) {
        parent = parent.parent
    }

    return `This script depends on the 'bash-completion' package.
If it is not installed already, you can install it via your OS's package manager.

To load completions in your current shell session:

        source <(${use})

To load completions for every new session, execute once:

#### Linux:

        ${use} > /etc/bash_completion.d/${parent.name}

#### macOS:

        ${use} > /usr/local/etc/bash_completion.d/${parent.name}

You will need to start a new shell for this setup to take effect.
`
}

export function createBashCompletion(opts?: CreateCompletionOptions) {
    const cmd = new Command({
        name: opts?.name ?? 'bash',
        usage: opts?.usage ?? 'Generate the autocompletion script for bash',
        usageLong: opts?.usageLong ?? bashUsage,
        run() {
            let parent = cmd.parent!
            while (parent.parent) {
                parent = parent.parent
            }
            const root = fromCommand(parent)
            for (const child of parent.values()) {
                addChild(root, child)
            }

            const s = bashCompletion(root)
            console.log(s)
        },
    })
    return cmd
}